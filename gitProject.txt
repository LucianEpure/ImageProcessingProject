// OpenCVApplication.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "common.h"
#include <iostream>

#define PATCH_SIZE 15

typedef struct point {
	int x, y, val;
}Tpoint;

typedef struct atmLight {
	int red, blue, green;
}Tatm;

int getMinFromPatch(int x, int y, Mat src) {
	int startI = max(x - PATCH_SIZE / 2, 0);
	int endI = min(x + PATCH_SIZE / 2, src.rows - 1);
	int startJ = max(y - PATCH_SIZE / 2, 0);
	int endJ = min(y + PATCH_SIZE / 2, src.cols - 1);

	int minR = src.at<Vec3b>(x, y)[2];
	int minG = src.at<Vec3b>(x, y)[1];
	int minB = src.at<Vec3b>(x, y)[0];

	Vec3b pixel;
	for (int i = startI; i <= endI; i++) {
		for (int j = startJ; j <= endJ; j++) {
			pixel = src.at<Vec3b>(i, j);
			if (pixel[2] < minR) minR = pixel[2];
			if (pixel[1] < minG) minG = pixel[1];
			if (pixel[0] < minB) minB = pixel[0];
		}
	}
	return min(min(minR, minG), minB);
}

int getMaxFromPatch(int x, int y, Mat src) {
	int startI = max(x - PATCH_SIZE / 2, 0);
	int endI = min(x + PATCH_SIZE / 2, src.rows - 1);
	int startJ = max(y - PATCH_SIZE / 2, 0);
	int endJ = min(y + PATCH_SIZE / 2, src.cols - 1);

	int maxR = src.at<Vec3b>(x, y)[2];
	int maxG = src.at<Vec3b>(x, y)[1];
	int maxB = src.at<Vec3b>(x, y)[0];

	Vec3b pixel;
	for (int i = startI; i <= endI; i++) {
		for (int j = startJ; j <= endJ; j++) {
			pixel = src.at<Vec3b>(i, j);
			if (pixel[2] > maxR) maxR = pixel[2];
			if (pixel[1] > maxG) maxG = pixel[1];
			if (pixel[0] > maxB) maxB = pixel[0];
		}
	}
	return max(max(maxR, maxG), maxB);
}

Mat darkChannelPrior(Mat src) {
	Mat dest;
	dest = Mat(src.rows, src.cols, CV_8UC1);
	printf("Size of source is (%d x %d)", src.rows, src.cols);
	for (int i = 0; i < src.rows; i++) {
		for (int j = 0; j < src.cols; j++) {
			dest.at<uchar>(i, j) = getMinFromPatch(i, j, src);
		}
	}
	return dest;
}

Mat brightChannelPrior(Mat src) {
	Mat dest;
	dest = Mat(src.rows, src.cols, CV_8UC1);
	printf("Size of source is (%d x %d)", src.rows, src.cols);
	for (int i = 0; i < src.rows; i++) {
		for (int j = 0; j < src.cols; j++) {
			dest.at<uchar>(i, j) = getMaxFromPatch(i, j, src);
		}
	}
	return dest;
}

Mat imageTransformerInterface(Mat(*f)(Mat)) {
	char fname[MAX_PATH];
	Mat src, dest;
	while (openFileDlg(fname))
	{
		src = imread(fname, CV_LOAD_IMAGE_COLOR);
		dest = f(src);
	//	imshow("src", src);
	//	imshow("dest", dest);
	}
	return dest;
}

void insertCorrect(uchar arr[], int val) {
	printf("size of array is %d\n", sizeof(arr));
	for (int i = 0; i < sizeof(arr); i++)
		arr[i] = 'a';
	
	
	/*int i = sizeof(arr);
	while ((i > arr[0]) && (val < arr[i - 1]))
	{
		arr[i] = arr[i - 1];
		i = i - 1;
	}
	arr[i] = val;*/
}

Tatm getAtmosphericLight(Mat brightChannel, Mat originalImage) {
	
		Mat src = brightChannel;
		int i, j;
		int topTen = 0;
		int totalSource = src.rows * src.cols;
		topTen = (10 * totalSource) / 100;
		int topTenClone = topTen;
		std::multimap<int, Point2i> pixelMap;
		Tatm atmosphericLight;
		atmosphericLight.blue = 0;
		atmosphericLight.green = 0;
		atmosphericLight.red = 0;
		
		bool fullArray = false;
		int pixArray[256];
		std::vector<Point2i> pixVector;
		float topTenSum = 0;
		
		for (i = 0; i < 256; i++)
		{
			pixArray[i] = 0;
		}
		
		for (i = 0; i < src.rows; i++) {
			for (j = 0; j < src.cols; j++) {
				pixArray[src.at<uchar>(i, j)]++;
				pixelMap.insert(std::pair<int, Point2i>(src.at<uchar>(i, j), Point2i(i, j)));
			}
		}
		for (i = 0; i < sizeof(pixArray) / sizeof(int); i++)
			std::cout << i << " " << pixArray[i] << "\n";
		
		std::cout <<"topTen float:"<< (float)topTen << "\n";
		i = sizeof(pixArray) / sizeof(int);
		while (topTenClone != 0) {
			
			std::pair<std::multimap<int, Point2i>::iterator, std::multimap<int, Point2i>::iterator> ret;
			ret = pixelMap.equal_range(i);
			
			for (std::multimap<int, Point2i>::iterator it = ret.first; it != ret.second; ++it)
			{
				pixVector.push_back(it->second);
			}
			while ((pixArray[i] > 0)&&(topTenClone!=0)) {	
				topTenClone--;
				pixArray[i]--;
			}
			i--;
		}
		float blueSum = 0.0f;
		float greenSum = 0.0f;
		float redSum = 0.0f;
		for (i = 0; i < topTen; i++) {
			//goodVector.push_back(pixVector.at(i));
			blueSum = blueSum + (float)originalImage.at<Vec3b>(pixVector.at(i).x, pixVector.at(i).y)[0] / topTen;
			greenSum = greenSum + (float)originalImage.at<Vec3b>(pixVector.at(i).x, pixVector.at(i).y)[1] / topTen;
			redSum = redSum + (float)originalImage.at<Vec3b>(pixVector.at(i).x, pixVector.at(i).y)[2] / topTen;
			//std::cout<<"TOPTEN:"<<topTen<<" I="<<i<< ": [ " << goodVector.at(i).x << ", "<<goodVector.at(i).y<<"]"<<std::endl;
		}
		std::cout << blueSum << " " << redSum << " " << greenSum << std::endl;
		atmosphericLight.blue = trunc(blueSum);
		atmosphericLight.red = trunc(redSum);
		atmosphericLight.green = trunc(greenSum);
		std::cout << "R:" << redSum << " G:" << greenSum << " B:" << blueSum << std::endl;
		return atmosphericLight;	
}

Mat computeTBright(Mat brightChannel, Tatm atmosphericLight, int color) {
	int i, j;
	Mat tBright = Mat::zeros(brightChannel.rows,brightChannel.cols,CV_32FC1);
	int atmosphericLightForColor = 0;
	if (color==0) {
		atmosphericLightForColor = atmosphericLight.blue;
		std::cout << "BBBBBBBBBBBBB";
	}
	else if (color == 1) {
		atmosphericLightForColor = atmosphericLight.green;
		std::cout << "GGGGGGGGGGG";
	}
	else if (color==2) {
		atmosphericLightForColor = atmosphericLight.red;
		std::cout << "RRRRRRRRRRR";
	}
	
	for (i = 0; i < brightChannel.rows; i++) {
		for (j = 0; j < brightChannel.cols; j++) {
			tBright.at<float>(i, j) = (float)(brightChannel.at<uchar>(i, j) - atmosphericLightForColor) / (255 - atmosphericLightForColor);
			//std::cout << "Tx:" << tBright.at<float>(i, j) << std::endl;
		}
	}
	return tBright;
}

Mat normalize(Mat src) {
		Mat dest = Mat::zeros(src.rows, src.cols, CV_8UC1);
		int minOut = 0, maxOut = 255;
		int maxIn = src.at<float>(0, 0);
		int minIn = src.at<float>(0, 0);

		for (int i = 0; i < src.rows; i++) {
			for (int j = 0; j < src.cols; j++) {
				if (src.at<float>(i, j) < minIn) minIn = src.at<float>(i, j);
				if (src.at<float>(i, j) > maxIn) maxIn = src.at<float>(i, j);
			}
		}

		for (int i = 0; i < src.rows; i++) {
			for (int j = 0; j < src.cols; j++) {
				dest.at<uchar>(i, j) = minOut + ((float)(src.at<float>(i, j) - minIn) / (maxIn - minIn)) * (maxOut - minOut);
			}
		}
		return dest;
}

boolean equalMat(Mat mat1, Mat mat2) {
	/*Mat_<uchar > mat3(mat1.rows, mat2.cols);
	mat3.setTo(255);
	mat3(1, 2) = 0;*/

	if (mat1.rows != mat2.rows) return false;
	if (mat1.cols != mat2.cols) return false;
	for (int i = 0; i < mat1.rows; i++) {
		for (int j = 0; j <mat1.cols; j++) {
			if (mat1.at<uchar>(i, j) != mat2.at<uchar>(i, j)) return false;
		}
	}
	return true;
}

Mat brightTransmissionView(Mat brightChannel, Tatm atmosphericLight) {
	Mat blueComponent = normalize(computeTBright(brightChannel, atmosphericLight, 0));

	Mat greenComponent = normalize(computeTBright(brightChannel, atmosphericLight, 1));

	Mat redComponent = normalize(computeTBright(brightChannel, atmosphericLight, 2));

	
	
	imshow("on red", redComponent);
	imshow("on blue", blueComponent);
	imshow("on green", greenComponent);

	if (equalMat(redComponent, blueComponent)) printf("red=blue");
	if (equalMat(greenComponent, blueComponent)) printf("green=blue");
	if (equalMat(greenComponent, redComponent)) printf("green=red");

	Mat transDest = Mat(brightChannel.rows, brightChannel.cols, CV_8UC3);
	for (int i = 0; i < brightChannel.rows; i++) {
		for (int j = 0; j < brightChannel.cols; j++) {
			transDest.at<Vec3b>(i, j)[0] = blueComponent.at<uchar>(i, j);
			transDest.at<Vec3b>(i, j)[1] = greenComponent.at<uchar>(i, j);
			transDest.at<Vec3b>(i, j)[2] = redComponent.at<uchar>(i, j);
		}
	}
	return transDest;
}



int main() {

	int op;
	/*do
	{
		system("cls");
		destroyAllWindows();
		printf("Menu:\n");
		printf(" 1 - Bright Channel Prior image\n");
		printf(" 2 - Dark Channel Prior image\n");
		printf("Option: ");
		scanf("%d", &op);
		switch (op)
		{
		case 1:
			getAtmosphericLight(imageTransformerInterface(brightChannelPrior));
			break;
		case 2:
			imageTransformerInterface(darkChannelPrior);
			break;
		}
	} while (op != 0);
	*/
	char fname[MAX_PATH];
	Mat originalImage, brightChannel, tBrightBlue, tBrightGreen, tBrightRed, showableTBright;
	showableTBright = Mat::zeros(originalImage.rows, originalImage.cols, CV_8UC3);
	Tatm atmospheric;
	while (openFileDlg(fname))
	{
		originalImage = imread(fname, CV_LOAD_IMAGE_COLOR);
		brightChannel = brightChannelPrior(originalImage);
		atmospheric = getAtmosphericLight(brightChannel,originalImage);
		showableTBright = brightTransmissionView(brightChannel, atmospheric);

		// on red
		imshow("tBrightTrans", showableTBright);
	}
	
	return 0;

}