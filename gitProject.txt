// OpenCVApplication.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "common.h"
#include <iostream>

#define PATCH_SIZE 15

typedef struct atmLight {
	int i, j, arrVal;
}atm;
int getMinFromPatch(int x, int y, Mat src) {
	int startI = max(x - PATCH_SIZE / 2, 0);
	int endI = min(x + PATCH_SIZE / 2, src.rows - 1);
	int startJ = max(y - PATCH_SIZE / 2, 0);
	int endJ = min(y + PATCH_SIZE / 2, src.cols - 1);

	int minR = src.at<Vec3b>(x, y)[2];
	int minG = src.at<Vec3b>(x, y)[1];
	int minB = src.at<Vec3b>(x, y)[0];

	Vec3b pixel;
	for (int i = startI; i <= endI; i++) {
		for (int j = startJ; j <= endJ; j++) {
			pixel = src.at<Vec3b>(i, j);
			if (pixel[2] < minR) minR = pixel[2];
			if (pixel[1] < minG) minG = pixel[1];
			if (pixel[0] < minB) minB = pixel[0];
		}
	}
	return min(min(minR, minG), minB);
}

int getMaxFromPatch(int x, int y, Mat src) {
	int startI = max(x - PATCH_SIZE / 2, 0);
	int endI = min(x + PATCH_SIZE / 2, src.rows - 1);
	int startJ = max(y - PATCH_SIZE / 2, 0);
	int endJ = min(y + PATCH_SIZE / 2, src.cols - 1);

	int maxR = src.at<Vec3b>(x, y)[2];
	int maxG = src.at<Vec3b>(x, y)[1];
	int maxB = src.at<Vec3b>(x, y)[0];

	Vec3b pixel;
	for (int i = startI; i <= endI; i++) {
		for (int j = startJ; j <= endJ; j++) {
			pixel = src.at<Vec3b>(i, j);
			if (pixel[2] > maxR) maxR = pixel[2];
			if (pixel[1] > maxG) maxG = pixel[1];
			if (pixel[0] > maxB) maxB = pixel[0];
		}
	}
	return max(max(maxR, maxG), maxB);
}

Mat darkChannelPrior(Mat src) {
	Mat dest;
	dest = Mat(src.rows, src.cols, CV_8UC1);
	printf("Size of source is (%d x %d)", src.rows, src.cols);
	for (int i = 0; i < src.rows; i++) {
		for (int j = 0; j < src.cols; j++) {
			dest.at<uchar>(i, j) = getMinFromPatch(i, j, src);
		}
	}
	return dest;
}

Mat brightChannelPrior(Mat src) {
	Mat dest;
	dest = Mat(src.rows, src.cols, CV_8UC1);
	printf("Size of source is (%d x %d)", src.rows, src.cols);
	for (int i = 0; i < src.rows; i++) {
		for (int j = 0; j < src.cols; j++) {
			dest.at<uchar>(i, j) = getMaxFromPatch(i, j, src);
		}
	}
	return dest;
}

void imageTransformerInterface(Mat(*f)(Mat)) {
	char fname[MAX_PATH];
	Mat src, dest;
	while (openFileDlg(fname))
	{
		src = imread(fname, CV_LOAD_IMAGE_COLOR);
		dest = f(src);
		imshow("src", src);
		imshow("dest", dest);
	}
}

void insertCorrect(uchar arr[], int val) {
	printf("size of array is %d\n", sizeof(arr));
	for (int i = 0; i < sizeof(arr); i++)
		arr[i] = 'a';
	
	
	/*int i = sizeof(arr);
	while ((i > arr[0]) && (val < arr[i - 1]))
	{
		arr[i] = arr[i - 1];
		i = i - 1;
	}
	arr[i] = val;*/
}

int getAtmosphericLight(Mat image) {
	
		Mat src = image;
		int i,j;
		int totalSource = src.rows * src.cols;
		int topTen = (10 * totalSource) / 100;
		int topTenClone = topTen;
		std::cout << "topTen" << topTen<<"\n";
		bool fullArray = false;
		int pixArray[256];
		float topTenSum = 0;
		for (i = 0; i < 256; i++)
		{
			pixArray[i] = 0;
		}
		
		for (i = 0; i < src.rows; i++) {
			for (j = 0; j < src.cols; j++) {
				pixArray[src.at<uchar>(i, j)]++;
			}
		}
		for (i = 0; i < sizeof(pixArray) / sizeof(int); i++)
			std::cout << i << " " << pixArray[i] << "\n";
		
		std::cout <<"topTen float:"<< (float)topTen << "\n";
		i = sizeof(pixArray) / sizeof(int);
		while (topTenClone != 0) {
			while ((pixArray[i] > 0)&&(topTenClone!=0)) {
				topTenSum = topTenSum + (float)i/topTen;
				std::cout <<"sum is:"<< topTenSum << "\n";
				topTenClone--;
				pixArray[i]--;
			}
			i--;
		}
		return floor(topTenSum);
}



int main() {

	int op;
	do
	{
		system("cls");
		destroyAllWindows();
		printf("Menu:\n");
		printf(" 1 - Bright Channel Prior image\n");
		printf(" 2 - Dark Channel Prior image\n");
		printf("Option: ");
		scanf("%d", &op);
		switch (op)
		{
		case 1:
			imageTransformerInterface(brightChannelPrior);
			break;
		case 2:
			imageTransformerInterface(darkChannelPrior);
			break;
		}
	} while (op != 0);
	return 0;

}