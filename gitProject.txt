// OpenCVApplication.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "common.h"
#include <iostream>

#define PATCH_SIZE 15

typedef struct point {
	int x, y, val;
}Tpoint;


typedef struct atmLight {
	int red, blue, green;
}Tatm;
int getMinFromPatch(int x, int y, Mat src) {
	int startI = max(x - PATCH_SIZE / 2, 0);
	int endI = min(x + PATCH_SIZE / 2, src.rows - 1);
	int startJ = max(y - PATCH_SIZE / 2, 0);
	int endJ = min(y + PATCH_SIZE / 2, src.cols - 1);

	int minR = src.at<Vec3b>(x, y)[2];
	int minG = src.at<Vec3b>(x, y)[1];
	int minB = src.at<Vec3b>(x, y)[0];

	Vec3b pixel;
	for (int i = startI; i <= endI; i++) {
		for (int j = startJ; j <= endJ; j++) {
			pixel = src.at<Vec3b>(i, j);
			if (pixel[2] < minR) minR = pixel[2];
			if (pixel[1] < minG) minG = pixel[1];
			if (pixel[0] < minB) minB = pixel[0];
		}
	}
	return min(min(minR, minG), minB);
}

int getMaxFromPatch(int x, int y, Mat src) {
	int startI = max(x - PATCH_SIZE / 2, 0);
	int endI = min(x + PATCH_SIZE / 2, src.rows - 1);
	int startJ = max(y - PATCH_SIZE / 2, 0);
	int endJ = min(y + PATCH_SIZE / 2, src.cols - 1);

	int maxR = src.at<Vec3b>(x, y)[2];
	int maxG = src.at<Vec3b>(x, y)[1];
	int maxB = src.at<Vec3b>(x, y)[0];

	Vec3b pixel;
	for (int i = startI; i <= endI; i++) {
		for (int j = startJ; j <= endJ; j++) {
			pixel = src.at<Vec3b>(i, j);
			if (pixel[2] > maxR) maxR = pixel[2];
			if (pixel[1] > maxG) maxG = pixel[1];
			if (pixel[0] > maxB) maxB = pixel[0];
		}
	}
	return max(max(maxR, maxG), maxB);
}

Mat darkChannelPrior(Mat src) {
	Mat dest;
	dest = Mat(src.rows, src.cols, CV_8UC1);
	printf("Size of source is (%d x %d)", src.rows, src.cols);
	for (int i = 0; i < src.rows; i++) {
		for (int j = 0; j < src.cols; j++) {
			dest.at<uchar>(i, j) = getMinFromPatch(i, j, src);
		}
	}
	return dest;
}

Mat brightChannelPrior(Mat src) {
	Mat dest;
	dest = Mat(src.rows, src.cols, CV_8UC1);
	printf("Size of source is (%d x %d)", src.rows, src.cols);
	for (int i = 0; i < src.rows; i++) {
		for (int j = 0; j < src.cols; j++) {
			dest.at<uchar>(i, j) = getMaxFromPatch(i, j, src);
		}
	}
	return dest;
}

Mat imageTransformerInterface(Mat(*f)(Mat)) {
	char fname[MAX_PATH];
	Mat src, dest;
	while (openFileDlg(fname))
	{
		src = imread(fname, CV_LOAD_IMAGE_COLOR);
		dest = f(src);
	//	imshow("src", src);
	//	imshow("dest", dest);
	}
	return dest;
}

void insertCorrect(uchar arr[], int val) {
	printf("size of array is %d\n", sizeof(arr));
	for (int i = 0; i < sizeof(arr); i++)
		arr[i] = 'a';
	
	
	/*int i = sizeof(arr);
	while ((i > arr[0]) && (val < arr[i - 1]))
	{
		arr[i] = arr[i - 1];
		i = i - 1;
	}
	arr[i] = val;*/
}

Tatm getAtmosphericLight(Mat brightChannel, Mat originalImage) {
	
		Mat src = brightChannel;
		int i, j;
		int topTen = 0;
		int totalSource = src.rows * src.cols;
		topTen = (10 * totalSource) / 100;
		int topTenClone = topTen;
		std::multimap<int, Point2i> pixelMap;
		Tatm atmosphericLight;
		atmosphericLight.blue = 0;
		atmosphericLight.green = 0;
		atmosphericLight.red = 0;
		
		bool fullArray = false;
		int pixArray[256];
		std::vector<Point2i> pixVector;
		std::vector<Point2i> goodVector;
		float topTenSum = 0;
		
		for (i = 0; i < 256; i++)
		{
			pixArray[i] = 0;
		}
		
		for (i = 0; i < src.rows; i++) {
			for (j = 0; j < src.cols; j++) {
				pixArray[src.at<uchar>(i, j)]++;
				pixelMap.insert(std::pair<int, Point2i>(src.at<uchar>(i, j), Point2i(i, j)));
			}
		}
		for (i = 0; i < sizeof(pixArray) / sizeof(int); i++)
			std::cout << i << " " << pixArray[i] << "\n";
		
		std::cout <<"topTen float:"<< (float)topTen << "\n";
		i = sizeof(pixArray) / sizeof(int);
		while (topTenClone != 0) {
			
			std::pair<std::multimap<int, Point2i>::iterator, std::multimap<int, Point2i>::iterator> ret;
			ret = pixelMap.equal_range(i);
			
			for (std::multimap<int, Point2i>::iterator it = ret.first; it != ret.second; ++it)
			{
				pixVector.push_back(it->second);
			}
			while ((pixArray[i] > 0)&&(topTenClone!=0)) {	
				topTenClone--;
				pixArray[i]--;
			}
			i--;
		}
		float blueSum = 0.0f;
		float greenSum = 0.0f;
		float redSum = 0.0f;
		for (i = 0; i < topTen; i++) {
			//goodVector.push_back(pixVector.at(i));
			blueSum = blueSum + (float)originalImage.at<Vec3b>(pixVector.at(i).x, pixVector.at(i).y)[0] / topTen;
			greenSum = greenSum + (float)originalImage.at<Vec3b>(pixVector.at(i).x, pixVector.at(i).y)[1] / topTen;
			redSum = redSum + (float)originalImage.at<Vec3b>(pixVector.at(i).x, pixVector.at(i).y)[2] / topTen;
			//std::cout<<"TOPTEN:"<<topTen<<" I="<<i<< ": [ " << goodVector.at(i).x << ", "<<goodVector.at(i).y<<"]"<<std::endl;
		}
		std::cout << blueSum << " " << redSum << " " << greenSum << std::endl;
		atmosphericLight.blue = trunc(blueSum);
		atmosphericLight.red = trunc(redSum);
		atmosphericLight.green = trunc(greenSum);
		return atmosphericLight;	
}

Mat computeTBright(Mat brightChannel, Tatm atmosphericLight, String color) {
	int i, j;
	Mat tBright = Mat::zeros(brightChannel.rows,brightChannel.cols,CV_32FC1);
	int atmosphericLightForColor = 0;
	if (color.compare("blue")) {
		atmosphericLightForColor = atmosphericLight.blue;
	}
	else if (color.compare("red")) {
		atmosphericLightForColor = atmosphericLight.red;
	}
	else if (color.compare("green")) {
		atmosphericLightForColor = atmosphericLight.green;
	}
	for (i = 0; i < brightChannel.rows; i++) {
		for (j = 0; j < brightChannel.cols; j++) {
			tBright.at<float>(i, j) = (float)(brightChannel.at<uchar>(i, j) - atmosphericLightForColor) / (255 - atmosphericLightForColor);
			//std::cout << "Tx:" << tBright.at<float>(i, j) << std::endl;
		}
	}
	return tBright;
}
/*
Mat normalize(Mat toNormalize) {

	Mat imagOut = Mat::zeros(toNormalize.rows, toNormalize.cols, CV_8UC1);
	for (int i = 0; i < toNormalize.rows; i++) {
		for (int j = 0; j < toNormalize.cols; j++) {
			if (toNormalize.at<float>(i, j) >255)
				imagOut.at<uchar>(i, j) = 255;
			else if (toNormalize.at<float>(i, j) < 0)
			{
				imagOut.at<uchar>(i, j) = abs(imagOut.at<uchar>(i, j));
				if (imagOut.at<uchar>(i, j)>255)
					imagOut.at<uchar>(i, j) = 255;
			}
			else
				imagOut.at<uchar>(i, j) = toNormalize.at<float>(i, j);
		}
	}
	return imagOut;
}*/



int main() {

	int op;
	/*do
	{
		system("cls");
		destroyAllWindows();
		printf("Menu:\n");
		printf(" 1 - Bright Channel Prior image\n");
		printf(" 2 - Dark Channel Prior image\n");
		printf("Option: ");
		scanf("%d", &op);
		switch (op)
		{
		case 1:
			getAtmosphericLight(imageTransformerInterface(brightChannelPrior));
			break;
		case 2:
			imageTransformerInterface(darkChannelPrior);
			break;
		}
	} while (op != 0);
	*/
	char fname[MAX_PATH];
	Mat originalImage, brightChannel, tBrightBlue, tBrightGreen, tBrightRed, showableTBright;
	showableTBright = Mat::zeros(originalImage.rows, originalImage.cols, CV_8UC3);
	Tatm atmospheric;
	while (openFileDlg(fname))
	{
		originalImage = imread(fname, CV_LOAD_IMAGE_COLOR);
		brightChannel = brightChannelPrior(originalImage);
		atmospheric = getAtmosphericLight(brightChannel,originalImage);
		tBrightBlue = computeTBright(brightChannel, atmospheric, "blue");
		tBrightRed = computeTBright(brightChannel, atmospheric, "red");
		tBrightGreen = computeTBright(brightChannel, atmospheric, "green");
		/*for (int i = 0; i < originalImage.rows; i++) {
			for (int j = 0; j < originalImage.cols; j++) {
				showableTBright.at<Vec3b>(i, j)[0] = tBrightBlue.at<float>(i, j);
				showableTBright.at<Vec3b>(i, j)[1] = tBrightGreen.at<float>(i, j);
				showableTBright.at<Vec3b>(i, j)[2] = tBrightRed.at<float>(i, j);
			}
		}*/
		//showableTBright = normalize(tBright);
		imshow("tBrightR", tBrightRed);
		imshow("tBrightB", tBrightBlue);
		imshow("tBrightG", tBrightGreen);
	}
	
	return 0;

}